<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>{{TITLE}} • Touring Guide</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="../css/base.css" />
  <link rel="stylesheet" href="../css/book.css" />
  <link rel="stylesheet" href="../css/map.css" />
  <link rel="stylesheet" href="../css/tour.css" />

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <style>
    #map { height: 420px; width: 100%; border-radius: 12px; }

    .elev-wrap{
      margin-top: 10px;
      border-radius: 12px;
      border: 2px solid rgba(0,0,0,0.25); /* stronger border */
      padding: 10px;
      position: relative;
      background: #fff;
    }
    .elev-head{
      display:flex;
      gap:10px;
      align-items:baseline;
      justify-content:space-between;
      margin-bottom:8px;
    }
    .elev-title{ font-weight: 700; }
    .elev-stats{ opacity: 0.95; font-size: 0.95rem; }

    /* HIGH CONTRAST CANVAS */
    #elevCanvas{
      width:100%;
      height:190px;
      display:block;
      border-radius:10px;
      background:#fff;                 /* solid white */
      border:2px solid rgba(0,0,0,0.25); /* visible frame */
    }

    .elev-note{
      margin-top: 6px;
      opacity: 0.85;
      font-size: 0.95rem;
      display: none;
    }

    .elev-tooltip{
      position:absolute;
      pointer-events:none;
      padding:6px 8px;
      border-radius:10px;
      border:2px solid rgba(0,0,0,0.25);
      background: rgba(255,255,255,0.98);
      font-size: 0.95rem;
      transform: translate(10px, -10px);
      display:none;
      white-space:nowrap;
      z-index:10;
      color:#111;
    }

    .map-error{
      margin-top:10px;
      padding:10px 12px;
      border:2px solid rgba(0,0,0,0.25);
      border-radius:10px;
      font-size:0.95rem;
      background: rgba(255, 235, 235, 0.95);
      display:none;
    }
    .map-error code { font-size: 0.9em; }
  </style>
</head>

<body>
  <main class="tour-wrap">

    <nav class="tour-nav">
      <a href="../guide.html">← Back to guide</a>
      <a href="{{GPX_URL}}" download class="btn">Download GPX</a>
    </nav>

    <header class="tour-header">
      <h1 class="tour-title">{{TITLE}}</h1>
      <p class="tour-sub">{{PROVINCE}} • {{REGION}}</p>
    </header>

    <section class="tour-map">
      <div id="map"></div>

      <!-- Elevation profile -->
      <div class="elev-wrap" id="elevWrap">
        <div class="elev-head">
          <div class="elev-title">Elevation profile</div>
          <div class="elev-stats" id="elevStats">loading…</div>
        </div>
        <canvas id="elevCanvas"></canvas>
        <div class="elev-note" id="elevNote">No elevation data found in this GeoJSON.</div>
        <div class="elev-tooltip" id="elevTooltip"></div>
      </div>

      <div id="mapError" class="map-error"></div>
    </section>

    <section class="tour-content">
      {{CONTENT_HTML}}
    </section>

  </main>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    const slug = "{{SLUG}}";
    const detailUrl = `../data/tours_detail/${slug}.geojson`;

    const map = L.map("map", { zoomControl: true });

    const openTopo = L.tileLayer(
      "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
      { maxZoom: 17, attribution: "&copy; OpenStreetMap contributors, SRTM | OpenTopoMap" }
    );
    const openStreet = L.tileLayer(
      "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
      { maxZoom: 19, attribution: "&copy; OpenStreetMap contributors" }
    );

    openTopo.addTo(map);
    L.control.layers({ "Topo": openTopo, "Street": openStreet }, null, { collapsed: true }).addTo(map);
    map.setView([50.0, -123.0], 7);

    function htmlEscape(s) {
      return String(s)
        .replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;").replaceAll("'", "&#039;");
    }
    function showError(msg, obj) {
      console.error(msg, obj || "");
      const el = document.getElementById("mapError");
      if (!el) return;
      el.style.display = "block";
      const extra = obj ? `<br><code>${htmlEscape(JSON.stringify(obj).slice(0, 600))}${JSON.stringify(obj).length > 600 ? "…" : ""}</code>` : "";
      el.innerHTML = `<strong>Map load error:</strong> ${htmlEscape(msg)}${extra}`;
    }

    function extractGeometry(gj) {
      if (!gj || typeof gj !== "object") return null;
      if (gj.type === "Feature" && gj.geometry) return gj.geometry;
      if (gj.type === "FeatureCollection" && Array.isArray(gj.features) && gj.features.length) {
        const f0 = gj.features[0];
        if (f0 && f0.geometry) return f0.geometry;
      }
      if (gj.geometry && gj.geometry.coordinates) return gj.geometry;
      if ((gj.type === "LineString" || gj.type === "MultiLineString") && gj.coordinates) return gj;
      if (gj.coordinates) return { type: "LineString", coordinates: gj.coordinates };
      return null;
    }

    function flattenToPoints(coords) {
      if (Array.isArray(coords) && coords.length && Array.isArray(coords[0]) && typeof coords[0][0] === "number") return coords;
      if (Array.isArray(coords)) return coords.flatMap(flattenToPoints);
      return [];
    }

    function haversineMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000, toRad = d => d * Math.PI / 180;
      const dLat = toRad(lat2 - lat1), dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    function setupElevationProfile(points, latlngs) {
      const note = document.getElementById("elevNote");
      const statsEl = document.getElementById("elevStats");
      const canvas = document.getElementById("elevCanvas");
      const tooltip = document.getElementById("elevTooltip");
      const elevWrap = document.getElementById("elevWrap");

      const elev = points.map(p => (p.length >= 3 && isFinite(p[2]) ? Number(p[2]) : null));
      const hasElev = elev.some(v => v !== null);

      if (!hasElev) {
        note.style.display = "block";
        statsEl.textContent = "no elevation";
        return;
      }

      const distKm = new Array(latlngs.length).fill(0);
      for (let i = 1; i < latlngs.length; i++) {
        const d = haversineMeters(latlngs[i-1][0], latlngs[i-1][1], latlngs[i][0], latlngs[i][1]);
        distKm[i] = distKm[i-1] + d / 1000;
      }

      const elevVals = elev.filter(v => v !== null);
      const minE = Math.min(...elevVals);
      const maxE = Math.max(...elevVals);

      let gain = 0, loss = 0;
      for (let i = 1; i < elev.length; i++) {
        if (elev[i] === null || elev[i-1] === null) continue;
        const de = elev[i] - elev[i-1];
        if (de > 0) gain += de; else loss += -de;
      }

      statsEl.textContent =
        `${distKm[distKm.length-1].toFixed(1)} km • ↑ ${Math.round(gain)} m • ↓ ${Math.round(loss)} m • ${Math.round(minE)}–${Math.round(maxE)} m`;

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.max(1, Math.floor(rect.width * dpr));
        canvas.height = Math.max(1, Math.floor(rect.height * dpr));
        return { dpr, W: rect.width, H: rect.height };
      }

      function draw(cursorIdx = null) {
        const { dpr, W, H } = resizeCanvas();
        const ctx = canvas.getContext("2d");

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        const padL = 52, padR = 12, padT = 12, padB = 28;
        const plotW = W - padL - padR;
        const plotH = H - padT - padB;

        // SOLID WHITE BG
        ctx.globalAlpha = 1;
        ctx.fillStyle = "#fff";
        ctx.fillRect(0, 0, W, H);

        // GRID (VISIBLE)
        ctx.strokeStyle = "rgba(0,0,0,0.25)";
        ctx.lineWidth = 1;
        for (let i = 0; i <= 5; i++) {
          const y = padT + (i/5) * plotH;
          ctx.beginPath();
          ctx.moveTo(padL, y);
          ctx.lineTo(padL + plotW, y);
          ctx.stroke();
        }

        // LABELS (DARK)
        ctx.fillStyle = "#111";
        ctx.font = "12px system-ui, sans-serif";
        ctx.fillText(`${Math.round(maxE)} m`, 8, padT + 10);
        ctx.fillText(`${Math.round(minE)} m`, 8, padT + plotH);
        ctx.fillText("0 km", padL, H - 8);
        ctx.fillText(`${distKm[distKm.length-1].toFixed(1)} km`, padL + plotW - 48, H - 8);

        const totalKm = distKm[distKm.length-1] || 1;
        const xFor = i => padL + (distKm[i] / totalKm) * plotW;
        const yForE = e => {
          const t = (e - minE) / ((maxE - minE) || 1);
          return padT + (1 - t) * plotH;
        };

        // PROFILE PATH
        let firstIdx = -1;
        ctx.beginPath();
        for (let i = 0; i < elev.length; i++) {
          if (elev[i] === null) continue;
          if (firstIdx === -1) firstIdx = i;
          const x = xFor(i);
          const y = yForE(elev[i]);
          if (i === firstIdx) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }

        // STRONG FILL
        ctx.lineJoin = "round";
        ctx.lineCap  = "round";

        ctx.strokeStyle = "#000";
        ctx.lineWidth = 5;

        // Keep a copy of path for fill
        ctx.stroke();

        ctx.globalAlpha = 0.55;      // MUCH stronger fill
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.lineTo(padL + plotW, padT + plotH);
        ctx.lineTo(padL, padT + plotH);
        ctx.closePath();
        ctx.fill();
        ctx.globalAlpha = 1;

        // CURSOR
        if (cursorIdx !== null) {
          const e = elev[cursorIdx];
          if (e !== null) {
            const x = xFor(cursorIdx);
            const y = yForE(e);

            ctx.strokeStyle = "#000";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x, padT);
            ctx.lineTo(x, padT + plotH);
            ctx.stroke();

            ctx.fillStyle = "#000";
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      // marker synced to profile (also high visibility)
      const hoverMarker = L.circleMarker(latlngs[0], {
        radius: 7, opacity: 1, fillOpacity: 1,
        color: "#000", fillColor: "#000", weight: 2
      }).addTo(map);

      function nearestIndexFromX(clientX) {
        const rect = canvas.getBoundingClientRect();
        const x = clientX - rect.left;
        const padL = 52, padR = 12;
        const plotW = rect.width - padL - padR;
        const t = Math.max(0, Math.min(1, (x - padL) / (plotW || 1)));
        const targetKm = t * (distKm[distKm.length-1] || 0);

        let lo = 0, hi = distKm.length - 1;
        while (hi - lo > 1) {
          const mid = (lo + hi) >> 1;
          if (distKm[mid] < targetKm) lo = mid;
          else hi = mid;
        }
        return (Math.abs(distKm[hi] - targetKm) < Math.abs(distKm[lo] - targetKm)) ? hi : lo;
      }

      function updateTooltip(idx, clientX, clientY) {
        const e = elev[idx], d = distKm[idx];
        if (e === null) return;
        tooltip.style.display = "block";
        tooltip.innerHTML = `${d.toFixed(2)} km • ${Math.round(e)} m`;
        const wrapRect = elevWrap.getBoundingClientRect();
        tooltip.style.left = `${clientX - wrapRect.left}px`;
        tooltip.style.top  = `${clientY - wrapRect.top}px`;
      }

      canvas.addEventListener("mousemove", (ev) => {
        const idx = nearestIndexFromX(ev.clientX);
        draw(idx);
        hoverMarker.setLatLng(latlngs[idx]);
        updateTooltip(idx, ev.clientX, ev.clientY);
      });

      canvas.addEventListener("mouseleave", () => {
        tooltip.style.display = "none";
        draw(null);
      });

      draw(null);
      window.addEventListener("resize", () => draw(null));
    }

    fetch(detailUrl)
      .then(r => {
        if (!r.ok) throw new Error(`Failed to load GeoJSON (${r.status})`);
        return r.json();
      })
      .then(gj => {
        const geom = extractGeometry(gj);
        if (!geom || !geom.coordinates) {
          showError("Could not find geometry.coordinates in GeoJSON", { type: gj?.type, keys: Object.keys(gj || {}) });
          return;
        }

        const points = flattenToPoints(geom.coordinates).filter(p => Array.isArray(p) && p.length >= 2);
        if (points.length < 2) {
          showError(`Not enough coordinate points to draw (got ${points.length})`, { geomType: geom.type });
          return;
        }

        const latlngs = points.map(p => [Number(p[1]), Number(p[0])]);
        if (!isFinite(latlngs[0][0]) || !isFinite(latlngs[0][1])) {
          showError("Coordinates are not numeric (NaN). Check GeoJSON coordinate format.", { sample: points[0] });
          return;
        }

        const line = L.polyline(latlngs, { weight: 4, opacity: 0.95 }).addTo(map);
        map.fitBounds(line.getBounds().pad(0.18));

        L.circleMarker(latlngs[0], { radius: 6, opacity: 1, fillOpacity: 0.9 })
          .addTo(map).bindTooltip("Start");

        L.circleMarker(latlngs[latlngs.length - 1], { radius: 6, opacity: 1, fillOpacity: 0.9 })
          .addTo(map).bindTooltip("End");

        setupElevationProfile(points, latlngs);
      })
      .catch(err => showError(err.message || String(err)));
  </script>
</body>
</html>
